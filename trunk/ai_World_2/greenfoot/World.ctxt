#BlueJ class context
comment0.params=worldWidth\ worldHeight\ cellSize
comment0.target=World(int,\ int,\ int)
comment0.text=\nConstruct\ a\ new\ world.\ The\ size\ of\ the\ world\ (in\ number\ of\ cells)\ and\ the\nsize\ of\ each\ cell\ (in\ pixels)\ must\ be\ specified.\n\n@param\ worldWidth\ The\ width\ of\ the\ world\ (in\ cells).\n@param\ worldHeight\ The\ height\ of\ the\ world\ (in\ cells).\n@param\ cellSize\ Size\ of\ a\ cell\ in\ pixels.\n\n\n
comment1.params=width\ height\ cellSize
comment1.target=void\ initialize(int,\ int,\ int)
comment1.text=\nSets\ the\ size\ of\ the\ world.\ <br>\n\nThis\ will\ remove\ all\ objects\ from\ the\ world.\ TODO\ Maybe\ it\ shouldn't\!\n\n\n
comment10.target=int\ getCellSize()
comment10.text=\nReturn\ the\ size\ of\ a\ cell\ (in\ pixels).\n\n
comment11.params=object\ x\ y
comment11.target=void\ addObject(Actor,\ int,\ int)
comment11.text=\nAdd\ an\ Actor\ to\ the\ world\ (at\ the\ object's\ specified\ location).\n\n@param\ object\ The\ new\ object\ to\ add.\n@throws\ IndexOutOfBoundsException\ If\ the\ coordinates\ are\ outside\ the\nbounds\ of\ the\ world.\n\n
comment12.params=object
comment12.target=void\ removeObject(Actor)
comment12.text=\nRemove\ an\ object\ from\ the\ world.\n\n@param\ object\ the\ object\ to\ remove\n\n
comment13.params=objects
comment13.target=void\ removeObjects(Collection)
comment13.text=\nRemove\ a\ list\ of\ objects\ from\ the\ world.\n\n@param\ objects\ A\ list\ of\ Actors\ to\ remove.\n\n
comment14.params=cls
comment14.target=List\ getObjects(Class)
comment14.text=\nGet\ all\ the\ objects\ in\ the\ world.<br>\n\nIf\ iterating\ through\ these\ objects,\ you\ should\ synchronize\ on\ this\ world\nto\ avoid\ ConcurrentModificationException.\n<p>\n\nThe\ objects\ are\ returned\ in\ their\ paint\ order.\ The\ first\ object\ in\ the\nList\ is\ the\ one\ painted\ first.\ The\ last\ object\ is\ the\ one\ painted\ on\ top\nof\ all\ other\ objects.\n<p>\n\nIf\ a\ class\ is\ specified\ as\ a\ parameter,\ only\ objects\ of\ that\ class\ (or\nits\ subclasses)\ will\ be\ returned.\n<p>\n\n\n@param\ cls\ Class\ of\ objects\ to\ look\ for\ ('null'\ will\ find\ all\ objects).\n\n@return\ An\ unmodifiable\ list\ of\ objects.\n\n
comment15.target=void\ repaint()
comment15.text=\nRepaints\ the\ world.\ \n\n\n
comment16.params=x\ y\ cls
comment16.target=List\ getObjectsAt(int,\ int,\ Class)
comment16.text=\nReturn\ all\ objects\ at\ a\ given\ cell.\n<p>\n\nAn\ object\ is\ defined\ to\ be\ at\ that\ cell\ if\ its\ graphical\ representation\noverlaps\ with\ the\ cell\ at\ any\ point.\n\n@param\ x\ X-coordinate\ of\ the\ cell\ to\ be\ checked.\n@param\ y\ Y-coordinate\ of\ the\ cell\ to\ be\ checked.\n@param\ cls\ Class\ of\ objects\ to\ look\ return\ ('null'\ will\ return\ all\nobjects).\n\n
comment17.params=actor\ cls
comment17.target=List\ getIntersectingObjects(Actor,\ Class)
comment17.text=\nReturn\ all\ the\ objects\ that\ intersect\ the\ given\ object.\ This\ takes\ the\ngraphical\ extent\ of\ objects\ into\ consideration.\n\n@param\ actor\ An\ Actor\ in\ the\ world\n@param\ cls\ Class\ of\ objects\ to\ look\ for\ (null\ or\ Object.class\ will\ find\nall\ classes)\n\n
comment18.params=x\ y\ r\ cls
comment18.target=List\ getObjectsInRange(int,\ int,\ int,\ Class)
comment18.text=\nReturns\ all\ objects\ with\ the\ logical\ location\ within\ the\ specified\ncircle.\ In\ other\ words\ an\ object\ A\ is\ within\ the\ range\ of\ an\ object\ B\ if\nthe\ distance\ between\ the\ center\ of\ the\ two\ objects\ is\ less\ thatn\ r.\n\n@param\ x\ Center\ of\ the\ cirle\n@param\ y\ Center\ of\ the\ cirle\n@param\ r\ Radius\ of\ the\ cirle\n@param\ cls\ Class\ of\ objects\ to\ look\ for\ (null\ or\ Object.class\ will\ find\nall\ classes)\n\n
comment19.params=actor\ distance\ diag\ cls
comment19.target=List\ getNeighbours(Actor,\ int,\ boolean,\ Class)
comment19.text=\nReturns\ the\ neighbours\ to\ the\ given\ location.\ This\ method\ only\ looks\ at\nthe\ logical\ location\ and\ not\ the\ extent\ of\ objects.\ Hence\ it\ is\ most\nuseful\ in\ scenarios\ where\ objects\ only\ span\ one\ cell.\n\n\n@param\ x\ Location\n@param\ y\ Location\n@param\ distance\ Distance\ in\ which\ to\ look\ for\ other\ objects\n@param\ diag\ Is\ the\ distance\ also\ diagonal?\n@param\ cls\ Class\ of\ objects\ to\ look\ for\ (null\ or\ Object.class\ will\ find\nall\ classes)\n@return\ A\ collection\ of\ all\ neighbours\ found\n\n
comment2.params=image
comment2.target=void\ setBackground(GreenfootImage)
comment2.text=\nSet\ a\ background\ image\ for\ the\ world.\ If\ the\ image\ size\ is\ larger\ than\nthe\ world\ in\ pixels,\ it\ is\ clipped.\ If\ it\ is\ smaller\ than\ the\ world,\ it\nis\ tiled\ unless\ specifically\ stated\ to\ do\ otherwise\ (see\ setTiled()).\ A\npattern\ showing\ the\ cells\ can\ easily\ be\ shown\ by\ setting\ a\ background\nimage\ with\ a\ size\ equal\ to\ the\ cell\ size.\n\n@see\ \#setBackground(String)\n@see\ \#setTiled(boolean)\n@param\ image\ The\ image\ to\ be\ shown\n\n
comment20.params=x0\ y0\ angle\ length\ cls
comment20.target=List\ getObjectsInDirection(int,\ int,\ int,\ int,\ Class)
comment20.text=\nReturn\ all\ objects\ that\ intersect\ a\ straight\ line\ from\ the\ location\ at\ a\nspecified\ angle.\ The\ angle\ is\ clockwise.\n\n@param\ x\ x-coordinate\n@param\ y\ y-coordinate\n@param\ angle\ The\ angle\ relative\ to\ current\ rotation\ of\ the\ object.\n(0-359)\n@param\ length\ How\ far\ we\ want\ to\ look\ (in\ cells)\n@param\ cls\ Class\ of\ objects\ to\ look\ for\ (passing\ 'null'\ will\ find\ all\nobjects).\n\n
comment21.target=int\ getHeightInPixels()
comment21.text=\nGet\ the\ height\ of\ the\ world\ in\ pixels.\n\n
comment22.target=int\ getWidthInPixels()
comment22.text=\nGet\ the\ width\ of\ the\ world\ in\ pixels.\n\n
comment23.params=i
comment23.target=int\ toCellCeil(int)
comment24.params=i
comment24.target=int\ toCellFloor(int)
comment25.params=l
comment25.target=double\ getCellCenter(int)
comment25.text=\nReturns\ the\ center\ of\ the\ cell.\ It\ should\ be\ rounded\ down\ with\ Math.floor()\ if\ the\ integer\ version\ is\ needed.\n@param\ l\ Cell\ location.\n@return\ Absolute\ location\ of\ the\ cell\ center\ in\ pixels.\n\n
comment26.params=x\ y
comment26.target=Collection\ getObjectsAtPixel(int,\ int)
comment27.params=object\ oldX\ oldY
comment27.target=void\ updateObjectLocation(Actor,\ int,\ int)
comment28.params=object
comment28.target=void\ updateObjectSize(Actor)
comment29.params=x
comment29.target=void\ ensureWithinXBounds(int)
comment29.text=\nMethods\ that\ throws\ an\ exception\ if\ the\ location\ is\ out\ of\ bounds.\n\n@throws\ IndexOutOfBoundsException\n\n
comment3.params=filename
comment3.target=void\ setBackground(String)
comment3.text=\nSet\ a\ background\ image\ for\ the\ world\ from\ an\ image\ file.\ Images\ of\ type\n'jpeg',\ 'gif'\ and\ 'png'\ are\ supported.\ If\ the\ image\ size\ is\ larger\ than\nthe\ world\ in\ pixels,\ it\ is\ clipped.\ If\ it\ is\ smaller\ than\ the\ world,\ it\nis\ tiled\ unless\ specifically\ stated\ to\ do\ otherwise\ (see\ setTiled()).\ A\npattern\ showing\ the\ cells\ can\ easily\ be\ shown\ by\ setting\ a\ background\nimage\ with\ a\ size\ equal\ to\ the\ cell\ size.\n\n@see\ \#setBackground(GreenfootImage)\n@see\ \#setTiled(boolean)\n@param\ filename\ The\ file\ holding\ the\ image\ to\ be\ shown\n@throws\ IllegalArgumentException\ If\ the\ image\ can\ not\ be\ loaded.\n\n
comment30.params=y
comment30.target=void\ ensureWithinYBounds(int)
comment30.text=\nMethods\ that\ throws\ an\ exception\ if\ the\ location\ is\ out\ of\ bounds.\n\n@throws\ IndexOutOfBoundsException\n\n
comment31.target=void\ startSequence()
comment31.text=\nUsed\ to\ indicate\ the\ start\ of\ an\ animation\ sequence.\ For\ use\ in\ the\ncollision\ checker.\n\n@see\ greenfoot.collision.CollisionChecker\#startSequence()\n\n
comment32.params=object\ dx\ dy\ cls
comment32.target=Actor\ getOneObjectAt(Actor,\ int,\ int,\ Class)
comment33.params=object\ cls
comment33.target=Actor\ getOneIntersectingObject(Actor,\ Class)
comment34.target=List<Actor>\ getObjectsList()
comment34.text=\nGet\ the\ list\ of\ all\ objects\ in\ the\ world.\ This\ returns\ a\ live\ list\ which\nshould\ not\ be\ modified\ by\ the\ caller.\ If\ iterating\ over\ this\ list,\ it\nshould\ be\ synchronized\ on\ itself\ or\ the\ World\ to\ avoid\ concurrent\nmodifactions.\n\n
comment35.params=g
comment35.target=void\ paintDebug(Graphics)
comment36.target=Object\ getRemoteObjectTracker()
comment36.text=static\ Object\ getTransportField()\n{\nreturn\ transportField;\n}\n
comment37.params=obj
comment37.target=void\ setTransportField(Object)
comment4.target=GreenfootImage\ getBackground()
comment4.text=\nReturn\ the\ world's\ background\ image.\ The\ image\ may\ be\ used\ to\ draw\ onto\nthe\ world's\ background.\n\n@return\ The\ background\ image\n\n
comment5.params=x\ y
comment5.target=Color\ getColorAt(int,\ int)
comment5.text=\nReturn\ the\ color\ at\ the\ center\ of\ the\ cell.\ To\ paint\ a\ color,\ you\ need\ to\nget\ the\ background\ image\ for\ the\ world\ and\ paint\ on\ that.\n\n@see\ \#getBackground()\n@throws\ IndexOutOfBoundsException\ If\ the\ location\ is\ not\ within\ the\ world\nbounds.\ If\ there\ is\ no\ background\ image\ at\ the\ location\ it\nwill\ return\ Color.WHITE.\n\n
comment6.params=tiled
comment6.target=void\ setTiled(boolean)
comment6.text=\nIf\ set\ to\ true,\ the\ background\ image\ will\ be\ tiled\ to\ fill\ out\ the\ entire\nbackground\ of\ the\ world.\n\n@param\ tiled\ Whether\ it\ should\ tile\ the\ image\ or\ not.\n\n
comment7.target=boolean\ isTiled()
comment7.text=\nReturns\ true\ if\ the\ world\ is\ tiled.\n\n@return\ Whether\ the\ image\ is\ tilled.\n@see\ \#setTiled(boolean)\n\n
comment8.target=int\ getWidth()
comment8.text=\nReturn\ the\ width\ of\ the\ world\ (in\ number\ of\ cells).\n\n
comment9.target=int\ getHeight()
comment9.text=\nReturn\ the\ height\ of\ the\ world\ (in\ number\ of\ cells).\n\n
numComments=38
